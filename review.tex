\section{Обзор}\section{Обзор}

\texit{``Умные указатели'' (англ. smart pointer)} -- это объекты, которые хранят указатели на динамически аллоцированные участки памяти произвольного типа. Причем они автоматически очищают память по выходу из области видимости.
Сначала рассмотрим то, как они выглядят в С++, затем перейдем к обзору некоторых распространенных типов ``умных указателей''.

Простейший ``умный указатель'':
\begin{lstlisting}
/* Класс умного указателя */
template <typename T>
class smart_pointer {
    T *m_obj;
public:
    /* Отдаем ему во владение некий объект */
    smart_pointer(T *obj)
        : m_obj(obj)
    { }
    /* По выходу из области видимости этот объект мы уничтожим */
    ~smart_pointer() {
        delete m_obj;
    }
    /* Перегруженные операторы */
    /* Селектор. Позволяет обращаться к данным типа T посредством "стрелочки" */
    T* operator->() { return m_obj; }
    /* С помощью такого оператора можно разыменовать указатель и получать ссылку на
     * объект, который он хранит */
    T& operator* () { return *m_obj; }
}
int test {
    /* "Умный указатель начинает следить за объектом MyClass */
    smart_pointer<MyClass> pMyClass(new MyClass(/*params*/);    
    /* Обращаемся к методу класса MyClass посредством селектора */
    pMyClass->something();    
    /* Допустим, что для класса есть функция вывода его в ostream
     * Эта функция одним из параметров обычно получает ссылку на 
     * объект, который должен быть выведен на экран */
    std::cout << *pMyClass << std::endl;    
    /* в завершение работы программы объект MyClass будет удален */
}

\end{lstlisting}

Понятно, что ``умный указатель'' не лишен недостатков, например, не ясно как хранить в нем массив. Он ведет себя так же, как и обычный указатель, причем не нужно заботиться об освобождении памяти: все будет сделано автоматически.
Теперь, рассмотрим конкретные реализации ``умных указателей'' для С++:

\begin{enumerate}
\item boost::scoped_ptr
\item std::auto_ptr
\item std::tr1::shared_ptr (он же std::shared_ptr в C++11, либо boost::shared_ptr из boost)
\end {enumerate}

\Subsection{boost::scoped_ptr}

\texit{boost::scoped_ptr}\footnote{URL: http://www.boost.org/doc/libs/1_39_0/libs/smart_ptr/scoped_ptr.htm}} находится в библиотеке буст.\footnote{URL: \url{http://www.boost.org/ }}
Реализация простая и понятная, практически идентичная приведенной выше, за несколькими исключениями, одно из них: этот указатель не может быть скопирован (то есть у него приватный конструктор копирования и оператор присваивания). 

\begin{lstlisting}
#include <boost/scoped_ptr.hpp>
int test() {
    boost::scoped_ptr<int> ptr1(new int(6));
    boost::scoped_ptr<int> ptr2(new int(1));    
    ptr1 = ptr2; // Нельзя делать (приватный конструктор копирования).
}
\end{lstlisting}

Если бы было разрешено присваивание, то и ptr1 и ptr2 будут указывать на одну и ту же область памяти. А по выходу из функции оба удалятся. Соответственно, этот указатель нельзя передавать и в функции. Применять его стоит как указатель-обертка для каких-либо данных, которые выделяются динамически в начале функции и удаляются в конце, чтобы избавиться от заботы по поводу корректной очистки ресурсов.

\Subsection{std::auto_ptr}

Auto_ptr\footnote{URL:\url{http://www.cplusplus.com/reference/memory/auto_ptr/}} -- улучшенный вариант предыдущего, к тому же он есть в стандартной библиотеке. У него есть оператор присваивания и конструктор-копировщик, но работают они несколько необычно.
Пример:

\begin{lstlisting}
#include <memory>
int test() {
    std::auto_ptr<MyObject> ptr1(new MyObject);
    std::auto_ptr<MyObject> ptr2;    
    ptr2 = ptr1;
}
\end{lstlisting}

После операции присваивания в ptr2 будет лежать указатель на MyObject (который создан для ptr1), а в ptr1 не будет ничего. То есть ptr1 теперь обнулен. Это так называемая семантика перемещения. Кстати, оператор копирования поступает таким же образом.
Рассмотрим еще одну ситуацию. Например, есть функция, которая должна создавать какой-то объект:
\begin{lstlisting}
std::auto_ptr<MyObject> giveMeMyObject();
\end{lstlisting}
Это означает, что функция создает новый объект типа MyObject и отдает его в распоряжение. В силу такой необычной семантики auto_ptr нельзя использовать в контейнерах STL. Для этого есть shared_ptr.

\Subsection{std::shared_ptr (С++11)}

Shared_ptr\footnote{URL:\url{http://www.cplusplus.com/reference/memory/shared_ptr/}}-- ``умный указатель'' с подсчетом ссылок. Это значит, что где-то есть некая переменная, которая хранит количество указателей, которые ссылаются на объект. Если эта переменная становится равной нулю, то объект уничтожается. Счетчик инкрементируется при каждом вызове либо оператора копирования либо оператора присваивания. Так же у shared_ptr есть оператор приведения к bool, что в итоге дает привычный синтаксис указателей, не заботясь об освобождении памяти.
\begin{lstlisting}
#include <memory> 
#include <iostream>
int test() {
    std::shared_ptr<MyObject> ptr1(new MyObject);
    std::shared_ptr<MyObject> ptr2;    
    ptr2 = ptr1;    
    if (ptr2)
        std::cout << "Hello, world!\n";
}
\end{lstlisting}

Теперь и ptr2 и ptr1 указывают на один объект, а счетчик ссылок равен 2, По выходу из скоупа счетчик обнуляется, и объект уничтожается. Можно передавать этот указатель в функцию:
\begin{lstlisting}
int test(std::shared_ptr<MyObject> p1) {
    /* делать что-то */
}
\end{lstlisting}

Если передается указатель по ссылке, то счетчик не будет увеличен. Нужно быть уверенным, что объект MyObject будет жив, пока будет выполняться функция test.
\subsection{Вывод}
``Умные указатели'' -- это хорошо, но есть и минусы. 
Во-первых, это дополнительные ресурсы.
Во-вторых, существует проблема циклических ссылок, т.е. когда объект прямо или опосредованно ссылается на себя самого.
