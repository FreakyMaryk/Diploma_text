\section{Особенности языка С++}

 
Во введении мы выяснили, что “С++” - сложный язык программирования широкого назначения. На этом языке написано огромное количество всевозможных продуктов, таких как операционные системы, разнообразные прикладные программы, драйверы устройств, приложения для встраиваемых систем, высокопроизводительные серверы, а также развлекательные приложения.
Однако, у “С++” есть один крупный недостаток. Заключается он в том, что данный язык, в отличии от таких языков как Java, не предназначен для “сборки мусора”, вследствие чего под угрозу ставится производительность и безопасность кода.

\subsection{Введение} 

Как уже было сказано ранее, язык С++, изначально не предназначен для сборки мусора. Но с новыми стандартами язык становится более простым и удобным в использовании, появляются новые инструменты, операторы. Это позволяет подумать над тем, как организовать процесс сборки мусора так, чтобы программы удовлетворяющие ряду ограничений могли запускать этот процесс.

При реализации сборщика мусора JBGC был использован ряд новшевств, вошедших в последний стандарт языка С++ -- С++11, а также некоторые инструменты и операторы, описанные еще в более поздних стандартах: 
\begin{enumerate}
\item оператор typeid;
\item шаблоны простые и с переменным числом аргументов -  template ,variadic template;
\item  конструкторы, деструкторы и порядок их вызова;
\end{enumerate}
Далее рассмотрим вышеперечисленные пункты подробнее.
\subsection{Оператор typeid} 

В реализации сборщика мусора JBGC для осуществления обхода и маркировки всех объектов хранится метаинфомация.  Метаинформация создается не для каждого объекта, а для конкретного типа. Этого оказалось достаточно, для того, чтобы получить необходимую для сборщики мусора информацию. Набор всех указателей на метаинформацию хранится в отдельном списке. По типу объекта можно получить указатель на метаинформацию соответствующую типу с помощью специальной функции.

Каждый раз, при вызове gc\_new, для объекта происходит проверка на существование метаинформации для заданного типа объекта. Если метаинформация лежит в списке, то возвращатся указатель на нее и кладется в начало объекта, если нет, то конструируется новая, и указатель на метаинформацию добавляется в  специальный список с типом-ключом.

Для того, чтобы такой подход стал возможным, нужен инструмент, который позволит идентифицировать тип во время исполнения(run-time type identification -- RTTI\footnote{ http://msdn.microsoft.com/en-us/library/b2ay8610.aspx}). Такая возможность существует в языке С++ -- функция \textit{typeid}. Для использования этой функции необходимо включить заголовочный файл typeinfo.h, а также установить режим поддержки RTTI в опциях компилятора. Форма записи данно функции имеет следующий вид:
\lstinline[language= C++]{typeid(object)}, где object -- объект, чей тип следует определить. Функция \textit{typeid} вернет ссылку на объект типа typeinfo, который описывает тип объекта object. 

Когда функция \textit{typeid} применяется к указателю на базовый класс полиморфного класса, она автоматически возвращает тип объекта, на который указывает указатель, в том числе любой класс, выведенный из базового класса. (Как уже говорилось, полиморфным классом называется класс, содержащий хотя бы одну виртуальную функцию.)\footnote{http://www.c-cpp.ru/books/identifikaciya-tipa-vo-vremya-ispolneniya-rtti}

\pagebreak
Следующий кусок кода gc\_new JBGC демонстрирует использование функции \textit{typeid}:
\begin{lstlisting}[language= C++]

/* если количество смещений внутри объекта равно нулю */
if (sizeOfPointerList(offsets) == 0) { 
	if (DEBUGE_MODE) {
		printf("if (offsets.size() == 0) {\n");
		fflush(stdout);
	}
	/* если в списке пар содержится данная пара */
	if (contains(classMeta, typeid(T).name())) { 
		if (DEBUGE_MODE) {
			printf("contains meta for class %s\n", typeid(T).name());
		}
		/* получить указатель на метаинформацию для данной пары */
		m_inf->shell = getClassMetaPointer(classMeta, typeid(T).name());  
	}
	/* если в списке пар соответствий не найдено */ 
	else {
		 if (DEBUGE_MODE) {
			 printf("new meta for class %s\n", typeid(T).name());
 	}
	/* создать новую метаинформацию, вернуть указатель на нее,
	      записать в начало объекта */
	 m_inf->shell = generic_box_simple ();
	/* добавить новую пару в список */
	 addNewClassMetaInformation(typeid(T).name(), m_inf->shell); 
     }
\end{lstlisting}


\subsection{Template, variadic template} 

В сборщике мусора JBGC функция выделения памяти для шаблонов-объектов (англ.template objects) gc\_new  использует оператор \textit{placement new} (производит размещение (инициализацию) объекта путем вызова конструктора, и создание в памяти по указанному адресу\footnote{http://www.cplusplus.com/reference/new}) для инициализации классом области памяти. Для вызова в подобном случае конструктора не по умолчанию у шаблона-объекта,  используется шаблон с переменным числом аргументов (англ. varidic templates), предоставляющий информацию о типах передаваемых объектов.

\textit{Шаблоны} (англ. template) — средство языка C++, предназначенное для кодирования обобщённых алгоритмов, без привязки к некоторым параметрам (например, типам данных, размерам буферов, значениям по умолчанию). 

\textit{Шаблон с переменным числом аргументов}(англ. variadic template) — это класс или шаблон функции, поддерживающий произвольное число аргументов. Этот механизм особенно удобен для разработчиков библиотек C++, поскольку можно применить его к обоим шаблонам класса и шаблоны функций и таким образом предоставляют широкий спектр типобезопасных и нетривиальных функции и гибкости. Возможность использовать шаблоны с переменным числом аргументов появилась только в новом стандарте С++ -- С++11. 

Рассмотрим пример использования сборщика мусора JBGC  с конструктором объекта не по умолчанию,  наглядно демонстрирующий необходимость использования шаблона с переменным числом аргументов:
\pagebreak
\begin{lstlisting}[language= C++]
#include <libgc/libgc.h>
#include <stdio.h>

class A {
private:
	int size;
	gc_ptr<int> mas;
public:
  	// A () {}

	/* конструктор не по умолчанию*/
	A (int len, const gc_ptr<int> & ar) {
		printf("A ... ");
		fflush(stdout);
		size = len;
		this->mas = gc_new<int>(len);
		printf("gc_new...ends\n");
		fflush(stdout);
		for (int i = 0; i < len; i++) {
			mas[i] = ar[i];
		}
	printf("ends\n");
	fflush(stdout);
  	}
};

int main (void) {
	int len = 10;
	/* создается два умных указателя, первый на массив int, длины len ,второй такой же */
	gc_ptr<int> ar = gc_new<int>(len), br = gc_new<int>(len);
	
	/* заполняются массивы */
	for (int i = 0; i < len; i++) {
		ar[i] = i;
		 br[i] = len - i;
	}
	/* создается умный указатель на объект класса А */
	/* у умного указателя аргументы: имя класса, имя типа первого,второго поля;
	    * в круглых скобках  имена передаваемых конструктору объектов
	    */
	/* здесь и нужен шаблон с переменным числом аргументов,
	    * иначе не понятно, как определить тип второго объекта в конструкторе 
	    */
	gc_ptr<A> a = gc_new<A, int, gc_ptr<int>&>(len, ar);
	gc_ptr<A> b = gc_new<A, int, gc_ptr<int>&>(len, br);
	for (int i = 0; i < len; i++) {
		ar[i] += 10;
		br[i] += 100;
  	}
	a->print(); b->print();
	printf("\n");
	return 0;
}

\end{lstlisting}
 \subsection{Конструкторы, деструкторы и порядок их вызова} 

Важным фактом является то, что в С++  момент создания/удаления объекта можно отследить с помощью \textit{конструктора/деструктора} объекта. В сборщике мусора JBGC этот факт является одним из основопологающих всего процесса. При вызове конструктора gc\_ptr , вызывается функция добавления себя в список корней, в случае загрузки стековой рамки на стек и функцию удаления себя из этого списка в своем деструкторе, в случае вытеснения стековой рамки. Заметим, что порядок вызова деструкторов противоположен порядку вызову конструкторов. 